#' Description of the predict function for zeroSum s3 objects
#'
#' This function uses zeroSumFit objects to predict responses for
#' given data newx.
#'
#' @param object fit object generated by zeroSum()
#'
#' @param newx data matrix for which new responses should be predicted
#'       (rows==samples)
#'
#' @param s determines which lambda should be used for predicting: lambda.min or
#'        lamda.1SE.
#'
#' @param type determines the return type: "link" returns the linear predictor
#'        (data %*% coefs), "response" returns the probabilites if applied on a
#'        binomial or multinomial zeroSum fit. For the other cases "response"
#'        equals "link". The type "class" returns the predicted class label if
#'        applied on a binomial or multinomial zeroSum fit. For cox regeression
#'        the linear predictor is returned as default ("link") and
#'        exp(linear predictor)) for the type "response".
#'
#' @param ... other arguments for the normal predict function if the fit
#'            is not a zeroSum object
#'
#' @return predicted values
#'
#' @examples
#' set.seed(1)
#' x <- log2(exampleData$x + 1)
#' y <- exampleData$y
#' fit <- zeroSum(x, y, alpha = 1)
#' predict(fit, x, s = "lambda.min")
#' @export
predict.zeroSum <- function(object = NULL, newx = NULL, s = "lambda.min",
                            type = NULL, ...) {
    if (!any(class(newx) == "matrix") || typeof(newx) != "double") {
        stop("type of passed x is not a numeric matrix\n")
    }

    if (is.null(type)) {
        if (object$type == zeroSumTypes[4, 2]) {
            type <- "link"
        } else {
            type <- "response"
        }
    }

    beta <- as.matrix(coef(object, s = s))

    if (ncol(newx) != nrow(beta) - 1) {
        message1 <- sprintf(paste0(
            "newx has wrong dimensions: nrow=%d ",
            "(samples) ncol=%d (features). "
        ), nrow(newx), ncol(newx))
        message2 <- sprintf(paste0(
            "However, this zeroSum object is trained ",
            "for %d features!"
        ), length(beta[-1]))
        stop(paste0(message1, message2))
    }

    if (object$type == zeroSumTypes[1, 2]) {
        if (!(type %in% c("link", "response"))) {
            stop(paste0("type not supported for type ", zeroSumTypes[1, 1]))
        }
        predict <- newx %*% beta[-1, ] + beta[1, ]
        return(predict)
    } else if (object$type == zeroSumTypes[2, 2]) {
        if (!(type %in% c("link", "response", "class"))) {
            stop(paste0("type not supported for type ", zeroSumTypes[2, 1]))
        }

        N <- nrow(newx)
        y <- rep(0, N)
        xb <- newx %*% beta[-1, ] + beta[1, ]

        if (type == "link") {
            return(as.matrix(xb))
        }

        for (i in 1:N) {
            y[i] <- 1 / (1 + exp(-xb[i]))
        }

        if (type == "response") {
            return(as.matrix(y))
        }

        y[y >= 0.5] <- 1
        y[y < 0.5] <- 0
        return(as.matrix(y))
    } else if (object$type == zeroSumTypes[3, 2]) {
        if (!(type %in% c("link", "response", "class"))) {
            stop(paste0("type not supported for type ", zeroSumTypes[3, 1]))
        }

        N <- nrow(newx)
        xb <- newx %*% beta[-1, ]
        for (i in seq_len(ncol(xb))) {
            xb[, i] <- xb[, i] + beta[1, i]
        }

        if (type == "link") {
            return(as.matrix(xb))
        }

        xb <- exp(xb)
        prob <- xb / rowSums(xb)
        colnames(prob) <- as.character(seq_len(ncol(prob)))

        if (type == "response") {
            return(as.matrix(prob))
        }

        y <- rep(0, N)
        for (i in 1:N) {
            y[i] <- which.max(prob[i, ])
        }

        return(as.matrix(y))
    } else {
        if (!(type %in% c("link", "response"))) {
            stop(paste0("type not supported for type ", zeroSumTypes[4, 1]))
        }

        xb <- newx %*% beta[-1, ]

        if (type == "link") {
            return(as.matrix(xb))
        }

        if (type == "response") {
            return(as.matrix(exp(xb)))
        }
    }
}
