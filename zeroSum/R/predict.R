#' Description of the predict function for zeroSum s3 objects
#'
#' This function uses zeroSumFit objects or zeroSumCVFit objects
#' to predict responses for a given data newx.
#'
#' @param fit fit object generated by zeroSumCVFit() or zeroSumFit()
#'
#' @param newx data matrix for which new responses should be predicted (rows==samples)
#'
#' @param s determines which lambda should be used for prediction if the
#'          fit is a zeroSumCVFit object: lambda.min or lamda.1SE. If
#'          the fit is a zeroSumFit this argument is ignored.
#'
#' @param ... other arguments for the normal predict function if the fit
#'            is not a zeroSum object
#'
#' @return predicted values
#'
#' @examples
#' set.seed(1)
#' x <- log2(exampleData$x+1)
#' y <- exampleData$y
#' fit <- zeroSumCVFit( x, y, alpha=1)
#' predict(fit, x, s="lambda.min")
#'
#' @export
predict <- function( fit=NULL, newx=NULL, s="lambda.min", ... )
{
    if( any( class(fit)=="ZeroSumCVFit") || any( class(fit)=="ZeroSumFit") )  {

        if( class(newx) != "matrix" | typeof(newx) != "double"  )  {
            stop("type of passed x is not a numeric matrix\n")
        }

        beta <- coef(fit, s=s)

        if( ncol(newx) != length(beta[-1]) ){
            message1 <- sprintf("newx has wrong dimensions: nrow=%d (samples) ncol=%d (features). ",
                    nrow(newx), ncol(newx) )
            message2 <- sprintf("However, this zeroSum fit is trained for %d features!",
                    length(beta[-1]) )
            stop(paste0(message1, message2))
        }

        if( fit$type %in% zeroSumTypes[1:4,2] )
        {
            predict <- newx %*% beta[-1,] + beta[1,]
            return(predict)

        } else if(fit$type %in% zeroSumTypes[5:12,2] )
        {
            N <- nrow(newx)
            y <- rep(0,N)
            xb <- newx %*% beta[-1,] + beta[1,]
            for(i in 1:N)
            {
                y[i] <- 1 / (1+ exp(-xb[i]))
            }
            #y[ y>=0.5 ] <- 1
            #y[ y<0.5 ]  <- 0
            return(as.matrix(y))

        } else if( fit$type %in% zeroSumTypes[9:12,2] )
        {
            N <- nrow(newx)
            xb <- newx %*% beta[-1,] + beta[1,]
            xb <- exp(xb)
            prob <- xb / rowSums(xb)

            y <- rep(0,N)
            for(i in 1:N)
               y[i] <- which( prob[i,]== max(prob[i,]))

            return(as.matrix(prob))
        }

    } else
    {
        UseMethod("predict")
    }
}
