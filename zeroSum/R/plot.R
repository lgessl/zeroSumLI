#' Description of the plot function for zeroSum s3 objects
#'
#' This function plots the CV-Error and its standard deviation
#' against the value of lambda of a zeroSumCVFit. 
#'
#' @param fit fit object generated by zeroSumCVFit()
#'
#' @param main title of the generated plot
#'
#' @param ... other arguments for the normal predict function if 
#'              the fit is not a zeroSumCVFit object
#'
#' @return predicted values
#'
#' @examples
#' set.seed(1)
#' data <- simulateData()
#' fit <- zeroSumCVFit( data$x, data$y, alpha=1)
#' plot( fit, "test") 
#'
#' @import graphics
#'
#' @export
plot <- function( fit=NULL, main="", ... )
{
    if( any( class(fit)=="ZeroSumCVFit") )
    {
        if( fit$type == "zeroSumElNet" || fit$type == "elNet" )
        {
            y <- fit$CVError
            yER <- fit$CVError_SD
            x <- log( fit$lambdaSeq )
            
            yMin <- min(y - yER)
            yMax <- max(y + yER)

            xMin <- min(x)
            col <-rgb(0.0, 0.2, 0.4)
            plot( x, y,pch=16, cex=0.5, col="black",
                        xlab=NA, ylab=NA, ylim=c(yMin,yMax) )
                        
            title( main=main, line=2.5)
            n <- length( fit$numberOfBetas )
            steps <-floor(seq(1,n, length.out=15 ))

            axis( 3, line=0, at=x[steps], 
                labels=fit$numberOfBetas[steps]) 

            mtext(side=1, text=expression("log("~lambda~")"), line=2.5)
            mtext(side=2, text="Mean-Squared-Error", line=2.5)

            arrows(x, y-yER, x, y+yER, code=3, angle=90, length=0.05,
                    col=col, lwd=0.5)

            abline(v=x[fit$LambdaMinIndex], col="black")
            abline(v=x[fit$Lambda1SEIndex], col="black")
        }

    } else 
    {
        UseMethod("plot")          
    }  
}
    
