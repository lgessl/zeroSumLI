#' Description of the coef function for zeroSum s3 objects
#'
#' This function returns the coefficients of a zeroSum fit object.
#'
#' @param fit fit object generated by zeroSumCVFit() or zeroSumFit()
#'
#' @param s determines which lambda of a zeroSumCVFit should be returned:
#'          lambda.min or lamda.1SE
#' @param precision all coefficients below this thresshold are set to 0
#'
#' @param ... other arguments for the normal predict function if the fit
#'            is not a zeroSumFit or zeroSumCVFit object
#'
#' @return estimated coefficients
#'
#' @examples
#' set.seed(1)
#' x <- log2(exampleData$x+1)
#' y <- exampleData$y
#' fit <- zeroSumCVFit( x, y, alpha=1)
#' coef(fit, s="lambda.min")
#'
#' @export
coef <- function( fit=NULL, s="lambda.min", precision=1e-6, ... )
{
    if( any( class(fit)=="ZeroSumCVFit") || any( class(fit)=="ZeroSumFit") )
    {
        beta <- NULL
        if( any( class(fit)=="ZeroSumFit"))
        {
            beta <- fit$beta
        }
        else
        {
            if( fit$type %in% zeroSumTypes[1:12,2] )
            {
                if( s == "lambda.min")
                {
                    beta <- fit$coef[ fit$LambdaMinIndex, ]
                }
                else if( s == "lambda.1SE" || s == "lambda.1se")
                {
                    beta <- fit$coef[ fit$Lambda1SEIndex, ]
                }
                else
                {
                    beta <- fit$coef[s,]
                    if(is.na(beta))
                        stop("s not valid")
                }
            } else
            {
                if( s == "lambda.min")
                {
                    beta <- fit$coef[[ fit$LambdaMinIndex ]]
                }
                else if( s == "lambda.1SE" || s == "lambda.1se")
                {
                    beta <- fit$coef[[ fit$Lambda1SEIndex ]]
                }
                else
                {
                    beta <- fit$coef[[s]]
                    if(is.na(beta))
                        stop("s not valid")
                }
            }
        }

        beta <- as.matrix(beta)

        ## remove numerical uncertainties
        beta[ abs(beta) < precision ] <- 0.0

        ## try to remove numerical zerosum uncertainties
        if( fit$type %% 2 == 0 && sum(beta[-1,] != 0.0 ) )
        {
            delta = sum(beta[-1,,drop=FALSE])
            ids <- which( beta[-1,] != 0.0 )
            if( length(ids) > 0){
               beta[ids+1,] <- beta[ids+1,] - delta / length(ids)
            }
        }

        return( as.matrix(beta) )

    } else
    {
        UseMethod("coef")
    }
}
