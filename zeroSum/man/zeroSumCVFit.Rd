% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/zeroSumCVFit.R
\name{zeroSumCVFit}
\alias{zeroSumCVFit}
\title{Description of zeroSumCVFit function}
\usage{
zeroSumCVFit(x, y, lambdaSequence = 0, alpha = 1, epsilon = 0.001,
  lambdaSteps = 100, nFold = 10, foldid = NULL, offset = TRUE,
  parallel = FALSE, verbose = FALSE, type = "zeroSumElNet",
  algorithmCV = "CD", algorithmAllSamples = "CD+LS", precisionCV = 1e-06,
  precisionAllSamples = 1e-06, diagonalMoves = TRUE, lambdaScaler = 1,
  polish = 0, cvStop = 0.1)
}
\arguments{
\item{x}{data as a numeric matrix object (rows=samples). 
The zero-sum regression requires data on the log scale, i.e.
x should be log-transformed data.}

\item{y}{response vector to be predicted by x (length(y)==nrow(x))}

\item{lambdaSequence}{sequence of lambda values to be tested.
If lambda==0 a sequence will be approximated}

\item{alpha}{Lasso/Ridge adjustment: For alpha = 0 the elastic net becomes
a ridge regularization, for alpha = 1 the elastic net becomes
the lasso regularization}

\item{epsilon}{If a lambda sequence is estimated, lambdaMax is chosen such
that all coefficients become zero, i.e. lambdaMax is the upper
bound of the lambda sequence. The lower bound is calculated by
lambdaMin = lambdaMax * epsilon and can be adjusted by this
parameter.}

\item{lambdaSteps}{this parameters determines the number of lambda steps between
lambdaMin and lambdaMax, i.e higher values for lambdaSteps
increase the resolution of the regularization path.}

\item{nFold}{the number of folds used for the cross validation}

\item{foldid}{allows to determine the folds used for cross validation.}

\item{offset}{determines if an offset should be used in the
model or not (TRUE/FALSE)}

\item{parallel}{The cross validation is done within a foreach loop which can be
executed in parallel. 'doMC' or equivalent needs to be
registered before using this!}

\item{verbose}{verbose = TRUE enables output}

\item{type}{choose the regression type: elNet, zeroSumElNet}

\item{algorithmCV}{determines the algorithm used for the cross validation:
CD = Coordinate descent (very fast, not so accurate),
CD+LS = Coordinate descent + local search (fast, very accurate),
LS = local search (slow, accurate),
SA = simulated annealing (very slow, very accurate)}

\item{algorithmAllSamples}{determines the algorithm used for the creation of 
of the final models (lambda.min and lambda.1SE):
 CD = Coordinate descent (very fast, not so accurate),
 CD+LS = Coordinate descent + local search (fast, very accurate),
 LS = Local search (slow, accurate),
 SA = Simulated annealing (very slow, very accurate)}

\item{precisionCV}{stopping criterion of the used algorithms for the CV fit.
Determines how small the improvement of the cost function
has to be to stop the algorithm. Default is 1e-6.}

\item{precisionAllSamples}{stopping criterion of the used algorithms for 
the creation of the final models (lambda.min and lambda.1SE).
Default is 1e-6.}

\item{diagonalMoves}{allows the CD to use diagonal moves}

\item{lambdaScaler}{allows to adjust the approximated lambdaMax}

\item{polish}{enables a local search at the end of CD to polish the result}

\item{cvStop}{stops the CV progress if the model's CV-error becomes worse
for lower lambda values. The number of worse
values which is tolerated is calculated by multiplying
the lambdaSteps (Default: 100) with the value of cvStop
parameter. (Default: 0.1). Use cvStop = 0 or FALSE to
deactivate the cvStop.}
}
\value{
zeroSumCVFitObject
}
\description{
This function determines for a given dataset x, y and elastic net parameter
alpha an optimal lambda value by cross validation (cv). It returns
a linear model for the optimal lambda. An appropiate lambda sequence 
is estimated or can be passed as an argument. For each lambda value
an nFold cv error is calculated. The optimal lambda corresponds to the lowest
cv error.
}
\examples{
set.seed(1)
x <- log2(exampleData$x+1)
y <- exampleData$y
fit <- zeroSumCVFit( x, y, alpha=1)
plot( fit, "test")
coef(fit, s="lambda.min")

}

